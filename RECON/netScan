#!/usr/bin/python3 

import scapy.all as scapy
import time
import sys

print("#"* 155)
print("This program is used to discover a connected client/ clients on a network/subnet and return their IP address and MAC address.")
print("#"*155)
print("\n\n")
time.sleep(0.3)
def rerun():
	try:
		run = input("Do you wish to run the program again (y for yes and n for no.)? >> ")
		rerun2(run)
	except KeyboardInterrupt: ##To exit program gracefully if user hits ctrl+c.
		print("\n Exitting program")
		time.sleep(0.5)
		print("Aborted!")
		sys.exit()
def rerun2(run):
	if run == 'y' or run == 'Y':
		print("resetting...")
		time.sleep(0.5)
		scan()
	elif run == 'n' or run == 'n':
		print("\n")
		print("#"*155)
		print("Thank you for using NetScan!")
		print("Happy Hacking!")
		print("#" *155)
		sys.exit()
	else:
		print("Invalid response. Please enter 'y' for yes or 'n' for no.")
		rerun()

def scan():			
	try:
		ip = input("enter ip or subnet: ")		
		def scan2(ip):
			try:
				
				print("Preparing for broadcast....")
				time.sleep(1)
				arp_request = scapy.ARP(pdst=ip)    ##creates a ARP packet obeject. pdst sets destination ip.
				#arp_request.show() ##prints more details about the packet
				broadcast = scapy.Ether(dst="ff:ff:ff:ff:ff:ff") ##Creates an Ethernet object. Sends packet to broadcast MAC.
				#broadcast.show() ##prints more details about the packet
				arp_request_broadcast = broadcast/arp_request ## Combines the 2 above packets using "/".
				#arp_request_broadcast.show() ##prints more details about the packet.
				#scapy.ls(class) ##prints feilds that can be set by you for a class.
				#print(arp_request_broadcast.summary()) ##print what the packet says.
				answered_list, unanswered_list = scapy.srp(arp_request_broadcast, timeout=1, verbose=False)##Send an ARP with a custom Ether. Answer_list and unanswered_list capture the packets returned by the function. Since the function returns 2 values, we are using 2 variables.The timeout part is to make sure that the program movs on after 1 sec if a device does not answer. Verbose=False cuts the clutter out of the ouput.
				print("\n\n")
				print('#' * 155)
				client_list = [] 
				for element in answered_list:
					client_dict = {"ip": element[1].psrc, "mac": element[1].hwsrc} ##Stores only important data from answered_list in a dictionary.
					client_list.append(client_dict)
				return(client_list)
			except KeyboardInterrupt: ##To exit program gracefully if user hits ctrl+c.
				print("\n Cancelling broadcast...")
				time.sleep(0.5)
				print("Aborted!")
				rerun()
		def print_result(results_list): ##Just to make the code more organised. Prints the results of scan2 function.
			print("IP\t\t\t Mac Address")
			print("#"*155)
			for client in results_list:
				print(client["ip"] + "\t\t" + client["mac"])
				print("- "*79)
			rerun()
			
	except KeyboardInterrupt: ##To exit program gracefully if user hits ctrl+c.
				print("\n Exitting program")
				time.sleep(0.5)
				print("Aborted!")
				sys.exit()
	scan_result = scan2(ip)
	print_result(scan_result)
scan()